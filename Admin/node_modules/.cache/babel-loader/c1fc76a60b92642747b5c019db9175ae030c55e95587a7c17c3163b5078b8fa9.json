{"ast":null,"code":"var __defProp = Object.defineProperty;\nvar __name = (target, value) => __defProp(target, \"name\", {\n  value,\n  configurable: true\n});\n\n// index.ts\nimport { featureCollection, isNumber, isObject, lineString, point, polygon, validateBBox } from \"@turf/helpers\";\nfunction randomPosition(bbox) {\n  checkBBox(bbox);\n  return randomPositionUnchecked(bbox);\n}\n__name(randomPosition, \"randomPosition\");\nfunction randomPositionUnchecked(bbox) {\n  if (Array.isArray(bbox)) {\n    return coordInBBox(bbox);\n  }\n  if (bbox && bbox.bbox) {\n    return coordInBBox(bbox.bbox);\n  }\n  return [lon(), lat()];\n}\n__name(randomPositionUnchecked, \"randomPositionUnchecked\");\nfunction checkBBox(bbox) {\n  if (bbox == null) {\n    return;\n  } else if (Array.isArray(bbox)) {\n    validateBBox(bbox);\n  } else if (bbox.bbox != null) {\n    validateBBox(bbox.bbox);\n  }\n}\n__name(checkBBox, \"checkBBox\");\nfunction randomPoint(count) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  checkBBox(options.bbox);\n  if (count === void 0 || count === null) {\n    count = 1;\n  }\n  const features = [];\n  for (let i = 0; i < count; i++) {\n    features.push(point(randomPositionUnchecked(options.bbox)));\n  }\n  return featureCollection(features);\n}\n__name(randomPoint, \"randomPoint\");\nfunction randomPolygon(count) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  checkBBox(options.bbox);\n  if (count === void 0 || count === null) {\n    count = 1;\n  }\n  if (!isNumber(options.num_vertices) || options.num_vertices === void 0) {\n    options.num_vertices = 10;\n  }\n  if (!isNumber(options.max_radial_length) || options.max_radial_length === void 0) {\n    options.max_radial_length = 10;\n  }\n  const features = [];\n  for (let i = 0; i < count; i++) {\n    let vertices = [];\n    const circleOffsets = [...Array(options.num_vertices + 1)].map(Math.random);\n    circleOffsets.forEach((cur, index, arr) => {\n      arr[index] = index > 0 ? cur + arr[index - 1] : cur;\n    });\n    circleOffsets.forEach(cur => {\n      cur = cur * 2 * Math.PI / circleOffsets[circleOffsets.length - 1];\n      const radialScaler = Math.random();\n      vertices.push([radialScaler * (options.max_radial_length || 10) * Math.sin(cur), radialScaler * (options.max_radial_length || 10) * Math.cos(cur)]);\n    });\n    vertices[vertices.length - 1] = vertices[0];\n    vertices = vertices.map(vertexToCoordinate(randomPositionUnchecked(options.bbox)));\n    features.push(polygon([vertices]));\n  }\n  return featureCollection(features);\n}\n__name(randomPolygon, \"randomPolygon\");\nfunction randomLineString(count) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  options = options || {};\n  if (!isObject(options)) {\n    throw new Error(\"options is invalid\");\n  }\n  const bbox = options.bbox;\n  checkBBox(bbox);\n  let num_vertices = options.num_vertices;\n  let max_length = options.max_length;\n  let max_rotation = options.max_rotation;\n  if (count === void 0 || count === null) {\n    count = 1;\n  }\n  if (!isNumber(num_vertices) || num_vertices === void 0 || num_vertices < 2) {\n    num_vertices = 10;\n  }\n  if (!isNumber(max_length) || max_length === void 0) {\n    max_length = 1e-4;\n  }\n  if (!isNumber(max_rotation) || max_rotation === void 0) {\n    max_rotation = Math.PI / 8;\n  }\n  const features = [];\n  for (let i = 0; i < count; i++) {\n    const startingPoint = randomPositionUnchecked(bbox);\n    const vertices = [startingPoint];\n    for (let j = 0; j < num_vertices - 1; j++) {\n      const priorAngle = j === 0 ? Math.random() * 2 * Math.PI : Math.tan((vertices[j][1] - vertices[j - 1][1]) / (vertices[j][0] - vertices[j - 1][0]));\n      const angle = priorAngle + (Math.random() - 0.5) * max_rotation * 2;\n      const distance = Math.random() * max_length;\n      vertices.push([vertices[j][0] + distance * Math.cos(angle), vertices[j][1] + distance * Math.sin(angle)]);\n    }\n    features.push(lineString(vertices));\n  }\n  return featureCollection(features);\n}\n__name(randomLineString, \"randomLineString\");\nfunction vertexToCoordinate(hub) {\n  return cur => {\n    return [cur[0] + hub[0], cur[1] + hub[1]];\n  };\n}\n__name(vertexToCoordinate, \"vertexToCoordinate\");\nfunction rnd() {\n  return Math.random() - 0.5;\n}\n__name(rnd, \"rnd\");\nfunction lon() {\n  return rnd() * 360;\n}\n__name(lon, \"lon\");\nfunction lat() {\n  return rnd() * 180;\n}\n__name(lat, \"lat\");\nfunction coordInBBox(bbox) {\n  return [Math.random() * (bbox[2] - bbox[0]) + bbox[0], Math.random() * (bbox[3] - bbox[1]) + bbox[1]];\n}\n__name(coordInBBox, \"coordInBBox\");\nexport { randomLineString, randomPoint, randomPolygon, randomPosition };","map":{"version":3,"names":["featureCollection","isNumber","isObject","lineString","point","polygon","validateBBox","randomPosition","bbox","checkBBox","randomPositionUnchecked","__name","Array","isArray","coordInBBox","lon","lat","randomPoint","count","options","arguments","length","undefined","features","i","push","randomPolygon","num_vertices","max_radial_length","vertices","circleOffsets","map","Math","random","forEach","cur","index","arr","PI","radialScaler","sin","cos","vertexToCoordinate","randomLineString","Error","max_length","max_rotation","startingPoint","j","priorAngle","tan","angle","distance","hub","rnd"],"sources":["D:\\NXG_Deploy\\Admin\\node_modules\\@turf\\random\\index.ts"],"sourcesContent":["import {\n  BBox,\n  FeatureCollection,\n  LineString,\n  Point,\n  Polygon,\n  Position,\n} from \"geojson\";\nimport {\n  featureCollection,\n  isNumber,\n  isObject,\n  lineString,\n  point,\n  polygon,\n  validateBBox,\n} from \"@turf/helpers\";\n\n/**\n * Returns a random position within a {@link bounding box}.\n *\n * @name randomPosition\n * @param {Array<number>} [bbox=[-180, -90, 180, 90]] a bounding box inside of which positions are placed.\n * @returns {Array<number>} Position [longitude, latitude]\n * @throws {Error} if bbox is invalid\n * @example\n * var position = turf.randomPosition([-180, -90, 180, 90])\n * // => position\n */\nfunction randomPosition(bbox?: BBox | { bbox: BBox }): Position {\n  checkBBox(bbox);\n  return randomPositionUnchecked(bbox);\n}\n\n// does not check bbox for validity, that is handled by the exported functions\nfunction randomPositionUnchecked(bbox?: BBox | { bbox: BBox }): Position {\n  if (Array.isArray(bbox)) {\n    return coordInBBox(bbox);\n  }\n  if (bbox && bbox.bbox) {\n    return coordInBBox(bbox.bbox);\n  }\n  return [lon(), lat()];\n}\n\nfunction checkBBox(bbox?: BBox | { bbox: BBox }) {\n  if (bbox == null) {\n    return;\n  } else if (Array.isArray(bbox)) {\n    validateBBox(bbox);\n  } else if (bbox.bbox != null) {\n    validateBBox(bbox.bbox);\n  }\n}\n\n/**\n * Returns a random {@link point}.\n *\n * @name randomPoint\n * @param {number} [count=1] how many geometries will be generated\n * @param {Object} [options={}] Optional parameters\n * @param {Array<number>} [options.bbox=[-180, -90, 180, 90]] a bounding box inside of which geometries are placed.\n * @returns {FeatureCollection<Point>} GeoJSON FeatureCollection of points\n * @throws {Error} if bbox is invalid\n * @example\n * var points = turf.randomPoint(25, {bbox: [-180, -90, 180, 90]})\n * // => points\n */\nfunction randomPoint(\n  count?: number,\n  options: {\n    bbox?: BBox;\n  } = {}\n): FeatureCollection<Point, any> {\n  checkBBox(options.bbox);\n  if (count === undefined || count === null) {\n    count = 1;\n  }\n  const features = [];\n  for (let i = 0; i < count; i++) {\n    features.push(point(randomPositionUnchecked(options.bbox)));\n  }\n  return featureCollection(features);\n}\n\n/**\n * Returns a random {@link polygon}.\n *\n * @name randomPolygon\n * @param {number} [count=1] how many geometries will be generated\n * @param {Object} [options={}] Optional parameters\n * @param {Array<number>} [options.bbox=[-180, -90, 180, 90]] a bounding box inside of which geometries are placed.\n * @param {number} [options.num_vertices=10] is how many coordinates each LineString will contain.\n * @param {number} [options.max_radial_length=10] is the maximum number of decimal degrees latitude or longitude that a\n * vertex can reach out of the center of the Polygon.\n * @returns {FeatureCollection<Polygon>} GeoJSON FeatureCollection of polygons\n * @throws {Error} if bbox is invalid\n * @example\n * var polygons = turf.randomPolygon(25, {bbox: [-180, -90, 180, 90]})\n * // => polygons\n */\nfunction randomPolygon(\n  count?: number,\n  options: {\n    bbox?: BBox;\n    num_vertices?: number;\n    max_radial_length?: number;\n  } = {}\n): FeatureCollection<Polygon, any> {\n  checkBBox(options.bbox);\n  // Default param\n  if (count === undefined || count === null) {\n    count = 1;\n  }\n  if (!isNumber(options.num_vertices) || options.num_vertices === undefined) {\n    options.num_vertices = 10;\n  }\n  if (\n    !isNumber(options.max_radial_length) ||\n    options.max_radial_length === undefined\n  ) {\n    options.max_radial_length = 10;\n  }\n\n  const features = [];\n  for (let i = 0; i < count; i++) {\n    let vertices: any[] = [];\n    const circleOffsets = [...Array(options.num_vertices + 1)].map(Math.random);\n\n    // Sum Offsets\n    circleOffsets.forEach((cur: any, index: number, arr: any[]) => {\n      arr[index] = index > 0 ? cur + arr[index - 1] : cur;\n    });\n\n    // scaleOffsets\n    circleOffsets.forEach((cur: any) => {\n      cur = (cur * 2 * Math.PI) / circleOffsets[circleOffsets.length - 1];\n      const radialScaler = Math.random();\n      vertices.push([\n        radialScaler * (options.max_radial_length || 10) * Math.sin(cur),\n        radialScaler * (options.max_radial_length || 10) * Math.cos(cur),\n      ]);\n    });\n    vertices[vertices.length - 1] = vertices[0]; // close the ring\n\n    // center the polygon around something\n    vertices = vertices.map(\n      vertexToCoordinate(randomPositionUnchecked(options.bbox))\n    );\n    features.push(polygon([vertices]));\n  }\n  return featureCollection(features);\n}\n\n/**\n * Returns a random {@link linestring}.\n *\n * @name randomLineString\n * @param {number} [count=1] how many geometries will be generated\n * @param {Object} [options={}] Optional parameters\n * @param {Array<number>} [options.bbox=[-180, -90, 180, 90]] a bounding box inside of which geometries are placed.\n * @param {number} [options.num_vertices=10] is how many coordinates each LineString will contain.\n * @param {number} [options.max_length=0.0001] is the maximum number of decimal degrees that a\n * vertex can be from its predecessor\n * @param {number} [options.max_rotation=Math.PI / 8] is the maximum number of radians that a\n * line segment can turn from the previous segment.\n * @returns {FeatureCollection<LineString>} GeoJSON FeatureCollection of linestrings\n * @throws {Error} if bbox is invalid\n * @example\n * var lineStrings = turf.randomLineString(25, {bbox: [-180, -90, 180, 90]})\n * // => lineStrings\n */\nfunction randomLineString(\n  count?: number,\n  options: {\n    bbox?: BBox;\n    num_vertices?: number;\n    max_length?: number;\n    max_rotation?: number;\n  } = {}\n): FeatureCollection<LineString, any> {\n  // Optional parameters\n  options = options || {};\n  if (!isObject(options)) {\n    throw new Error(\"options is invalid\");\n  }\n  const bbox = options.bbox;\n  checkBBox(bbox);\n  let num_vertices = options.num_vertices;\n  let max_length = options.max_length;\n  let max_rotation = options.max_rotation;\n  if (count === undefined || count === null) {\n    count = 1;\n  }\n\n  // Default parameters\n  if (\n    !isNumber(num_vertices) ||\n    num_vertices === undefined ||\n    num_vertices < 2\n  ) {\n    num_vertices = 10;\n  }\n  if (!isNumber(max_length) || max_length === undefined) {\n    max_length = 0.0001;\n  }\n  if (!isNumber(max_rotation) || max_rotation === undefined) {\n    max_rotation = Math.PI / 8;\n  }\n\n  const features = [];\n  for (let i = 0; i < count; i++) {\n    const startingPoint = randomPositionUnchecked(bbox);\n    const vertices = [startingPoint];\n    for (let j = 0; j < num_vertices - 1; j++) {\n      const priorAngle =\n        j === 0\n          ? Math.random() * 2 * Math.PI\n          : Math.tan(\n              (vertices[j][1] - vertices[j - 1][1]) /\n                (vertices[j][0] - vertices[j - 1][0])\n            );\n      const angle = priorAngle + (Math.random() - 0.5) * max_rotation * 2;\n      const distance = Math.random() * max_length;\n      vertices.push([\n        vertices[j][0] + distance * Math.cos(angle),\n        vertices[j][1] + distance * Math.sin(angle),\n      ]);\n    }\n    features.push(lineString(vertices));\n  }\n\n  return featureCollection(features);\n}\n\nfunction vertexToCoordinate(hub: number[]) {\n  return (cur: number[]) => {\n    return [cur[0] + hub[0], cur[1] + hub[1]];\n  };\n}\n\nfunction rnd() {\n  return Math.random() - 0.5;\n}\nfunction lon() {\n  return rnd() * 360;\n}\nfunction lat() {\n  return rnd() * 180;\n}\n\nfunction coordInBBox(bbox: BBox) {\n  return [\n    Math.random() * (bbox[2] - bbox[0]) + bbox[0],\n    Math.random() * (bbox[3] - bbox[1]) + bbox[1],\n  ];\n}\n\nexport { randomPosition, randomPoint, randomPolygon, randomLineString };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}