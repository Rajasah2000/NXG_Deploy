{"ast":null,"code":"var __defProp = Object.defineProperty;\nvar __name = (target, value) => __defProp(target, \"name\", {\n  value,\n  configurable: true\n});\n\n// index.ts\nimport { bearing } from \"@turf/bearing\";\nimport { bearingToAzimuth, isObject } from \"@turf/helpers\";\nimport { rhumbBearing } from \"@turf/rhumb-bearing\";\nfunction angle(startPoint, midPoint, endPoint) {\n  let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  if (!isObject(options)) {\n    throw new Error(\"options is invalid\");\n  }\n  if (!startPoint) {\n    throw new Error(\"startPoint is required\");\n  }\n  if (!midPoint) {\n    throw new Error(\"midPoint is required\");\n  }\n  if (!endPoint) {\n    throw new Error(\"endPoint is required\");\n  }\n  const A = startPoint;\n  const O = midPoint;\n  const B = endPoint;\n  const azimuthAO = bearingToAzimuth(options.mercator !== true ? bearing(A, O) : rhumbBearing(A, O));\n  const azimuthBO = bearingToAzimuth(options.mercator !== true ? bearing(B, O) : rhumbBearing(B, O));\n  const angleAO = Math.abs(azimuthAO - azimuthBO);\n  if (options.explementary === true) {\n    return 360 - angleAO;\n  }\n  return angleAO;\n}\n__name(angle, \"angle\");\nvar turf_angle_default = angle;\nexport { angle, turf_angle_default as default };","map":{"version":3,"names":["bearing","bearingToAzimuth","isObject","rhumbBearing","angle","startPoint","midPoint","endPoint","options","arguments","length","undefined","Error","A","O","B","azimuthAO","mercator","azimuthBO","angleAO","Math","abs","explementary","__name","turf_angle_default"],"sources":["D:\\NXG_Deploy\\Admin\\node_modules\\@turf\\angle\\index.ts"],"sourcesContent":["import { bearing } from \"@turf/bearing\";\nimport { bearingToAzimuth, Coord, isObject } from \"@turf/helpers\";\nimport { rhumbBearing } from \"@turf/rhumb-bearing\";\n\n/**\n * Finds the angle formed by two adjacent segments defined by 3 points. The result will be the (positive clockwise)\n * angle with origin on the `startPoint-midPoint` segment, or its explementary angle if required.\n *\n * @name angle\n * @param {Coord} startPoint Start Point Coordinates\n * @param {Coord} midPoint Mid Point Coordinates\n * @param {Coord} endPoint End Point Coordinates\n * @param {Object} [options={}] Optional parameters\n * @param {boolean} [options.explementary=false] Returns the explementary angle instead (360 - angle)\n * @param {boolean} [options.mercator=false] if calculations should be performed over Mercator or WGS84 projection\n * @returns {number} Angle between the provided points, or its explementary.\n * @example\n * turf.angle([5, 5], [5, 6], [3, 4]);\n * //=45\n */\nfunction angle(\n  startPoint: Coord,\n  midPoint: Coord,\n  endPoint: Coord,\n  options: {\n    explementary?: boolean;\n    mercator?: boolean;\n  } = {}\n): number {\n  // Optional Parameters\n  if (!isObject(options)) {\n    throw new Error(\"options is invalid\");\n  }\n\n  // Validation\n  if (!startPoint) {\n    throw new Error(\"startPoint is required\");\n  }\n  if (!midPoint) {\n    throw new Error(\"midPoint is required\");\n  }\n  if (!endPoint) {\n    throw new Error(\"endPoint is required\");\n  }\n\n  // Rename to shorter variables\n  const A = startPoint;\n  const O = midPoint;\n  const B = endPoint;\n\n  // Main\n  const azimuthAO = bearingToAzimuth(\n    options.mercator !== true ? bearing(A, O) : rhumbBearing(A, O)\n  );\n  const azimuthBO = bearingToAzimuth(\n    options.mercator !== true ? bearing(B, O) : rhumbBearing(B, O)\n  );\n  const angleAO = Math.abs(azimuthAO - azimuthBO);\n\n  // Explementary angle\n  if (options.explementary === true) {\n    return 360 - angleAO;\n  }\n  return angleAO;\n}\n\nexport { angle };\nexport default angle;\n"],"mappings":";;;;;;;AAAA,SAASA,OAAA,QAAe;AACxB,SAASC,gBAAA,EAAyBC,QAAA,QAAgB;AAClD,SAASC,YAAA,QAAoB;AAkB7B,SAASC,MACPC,UAAA,EACAC,QAAA,EACAC,QAAA,EAKQ;EAAA,IAJRC,OAAA,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAGI,CAAC;EAGL,IAAI,CAACP,QAAA,CAASM,OAAO,GAAG;IACtB,MAAM,IAAII,KAAA,CAAM,oBAAoB;EACtC;EAGA,IAAI,CAACP,UAAA,EAAY;IACf,MAAM,IAAIO,KAAA,CAAM,wBAAwB;EAC1C;EACA,IAAI,CAACN,QAAA,EAAU;IACb,MAAM,IAAIM,KAAA,CAAM,sBAAsB;EACxC;EACA,IAAI,CAACL,QAAA,EAAU;IACb,MAAM,IAAIK,KAAA,CAAM,sBAAsB;EACxC;EAGA,MAAMC,CAAA,GAAIR,UAAA;EACV,MAAMS,CAAA,GAAIR,QAAA;EACV,MAAMS,CAAA,GAAIR,QAAA;EAGV,MAAMS,SAAA,GAAYf,gBAAA,CAChBO,OAAA,CAAQS,QAAA,KAAa,OAAOjB,OAAA,CAAQa,CAAA,EAAGC,CAAC,IAAIX,YAAA,CAAaU,CAAA,EAAGC,CAAC,CAC/D;EACA,MAAMI,SAAA,GAAYjB,gBAAA,CAChBO,OAAA,CAAQS,QAAA,KAAa,OAAOjB,OAAA,CAAQe,CAAA,EAAGD,CAAC,IAAIX,YAAA,CAAaY,CAAA,EAAGD,CAAC,CAC/D;EACA,MAAMK,OAAA,GAAUC,IAAA,CAAKC,GAAA,CAAIL,SAAA,GAAYE,SAAS;EAG9C,IAAIV,OAAA,CAAQc,YAAA,KAAiB,MAAM;IACjC,OAAO,MAAMH,OAAA;EACf;EACA,OAAOA,OAAA;AACT;AA5CSI,MAAA,CAAAnB,KAAA;AA+CT,IAAOoB,kBAAA,GAAQpB,KAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}